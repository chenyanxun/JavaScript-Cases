<!doctype html>
<html lang="zh-cn">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<meta name="Keywords" content="">
	<meta name="Description" content="">
	<style>
		* {
			padding:0px;
			margin:0px;
			-ms-user-select:none;
			-webkit-user-select:none;
			-moz-user-select:none;
			user-select:none;
		}
		ul {
			width:600px;
			height:600px;
			margin:100px auto 0px;
			list-style:none;
			position:relative;
		}
		li {
			width:100px;
			height:100px;
			background:#111;
			float:left;
			margin:0px 20px 20px 0px;
			color:#fff;
			font-size:30px;
			line-height:100px;
			text-align:center;
			cursor:move;
		}
	</style>
</head>
<body>
	<ul id="box">
		<li>1</li>
		<li>2</li>
		<li>3</li>
		<li>4</li>
		<li>5</li>
		<li>6</li>
		<li>7</li>
		<li>8</li>
		<li>9</li>
		<li>10</li>
		<li>11</li>
		<li>12</li>
		<li>13</li>
		<li>14</li>
		<li>15</li>
		<li>16</li>
		<li>17</li>
		<li>18</li>
		<li>19</li>
		<li>20</li>
	</ul>
	<script>
		window.onload = function(){
			var ulDom = document.getElementById("box");
			var liDoms = ulDom.children;
			var len = liDoms.length;
			var zIndex = 1;
			var arr = [];
			for(var i=0;i<len;i++){
				var top = liDoms[i].offsetTop;
				var left = liDoms[i].offsetLeft;
				arr.push([top,left]);
			}

			for(var i=0;i<len;i++){
				liDoms[i].index = i;
				liDoms[i].style.position = "absolute";
				liDoms[i].style.top = arr[i][0] + "px";
				liDoms[i].style.left = arr[i][1] + "px";
				drag(liDoms[i]);
			}
			// 拖拽
			function drag(dom){
				dom.onmousedown = function(e){
					var pos = getXY(e);
					var l = this.offsetLeft;
					var t = this.offsetTop;
					dom.style.zIndex = zIndex++;
					document.onmousemove = function(e){
						var nl = getXY(e).x - pos.x + l;
						var nt = getXY(e).y - pos.y + t;
						dom.style.left = nl + "px";
						dom.style.top = nt + "px";
						for(var i=0;i<len;i++){
							liDoms[i].style.background = "#111";
						}
						// 最短距离碰撞
						var nearLi = juli(dom);
						if(nearLi){
							nearLi.style.background = "red";
						}
					};	
					document.onmouseup = function(){
						document.onmousemove = null;
						document.onmouseup = null;
						var nearLi = juli(dom);
						var tempArr = arr[nearLi.index];
						if(nearLi){
							move(dom,{left:tempArr[1],top:tempArr[0]});
							move(nearLi,{left:arr[dom.index][1],top:arr[dom.index][0]});
							arr[nearLi.index] = arr[dom.index];
							arr[dom.index] = tempArr;
							nearLi.style.background = "#111";
						}else{
							move(dom,{left:arr[dom.index][1],top:arr[dom.index][0]});
						}
					}
				}			
			}
			// 碰撞
			function pengzhuang(dom1,dom2){
				var T1 = dom1.offsetTop;
				var R1 = dom1.offsetLeft + dom1.offsetWidth;
				var B1 = dom1.offsetTop + dom1.offsetHeight;
				var L1 = dom1.offsetLeft;

				var T2 = dom2.offsetTop;
				var R2 = dom2.offsetLeft + dom2.offsetWidth;
				var B2 = dom2.offsetTop + dom2.offsetHeight;
				var L2 = dom2.offsetLeft;
				// 没有碰撞的情况
				if(T1 > B2 || R1 < L2 || B1 < T2 || L1 > R2){
					return true;
				}else{
					return false;
				}
			};

			// 找到最近的元素交换
			function juli(dom){
				var value = Number.MAX_VALUE; // 对比数字
				var index = -1;
				// 循环检测碰撞元素
				for(var i=0;i<len;i++){
					if(!pengzhuang(dom,liDoms[i]) && dom!=liDoms[i]){
						var a = dom.offsetLeft - liDoms[i].offsetLeft;
						var b = dom.offsetTop - liDoms[i].offsetTop;
						var c = Math.sqrt(a*a + b*b);
						if(c<value){
							value = c;
							index = liDoms[i].index;
						}
					}
				}
				if(index != -1){
					return liDoms[index];
				}else{
					return false;
				}
			}
		}

		//获取鼠标的位置。兼容ie678
		function getXY(e){
			var ev = e || window.event;
			var x=0,y=0;
			if(ev.pageX){
				x = ev.pageX;
				y = ev.pageY;
			}else{
				//拿到scrollTop 和scrollLeft
				var sleft = 0,stop = 0;
				//ie678---
				if(document.documentElement){
					stop =document.documentElement.scrollTop;
					sleft = document.documentElement.scrollLeft;
				}else{
				//ie9+ 谷歌 
					stop = document.body.scrollTop;
					sleft = document.body.scrollLeft;
				}	
				x = ev.clientX + sleft;
				y = ev.clientY + stop;
			}
			return {x:x,y:y};
		};

		/*
			时间：2016-01-08
			作者：keke
			动画移动函数
			dom---dom对象
			json===={width:100,height:100}
			callback:回调函数
		*/
		function move(dom,json,callback){
			//让每一次动画都是全新的
			if(dom.timer)clearInterval(dom.timer);
			dom.timer = setInterval(function(){
				//所有元素执行完毕以后的状态
				var mark = true;
				//循环所有动画的属性
				for(var attr in json){
					var cur = null;
					//如果是opacity的透明的动画
					if(attr=="opacity"){
						//获取已经产生的透明度
						cur = getStyle(dom,attr) * 100;
					}else{
						//获取已经执行的距离
						cur = parseInt(getStyle(dom,attr)) || 0;
					}
					//获取目标终止值
					var target = json[attr];
					//速度，*0.2是增加摩擦力
					var speed = (target - cur)/8;
					//如果cur在执行过程中因为已经除去了小数部分。而速度可能会产生小数位 
					//所有说当cur执行的递增，那么可能cur到达不了目标,当速度是大于0的上取整，然后整数+speed==目标
					//199 +1 200 反之向下取整
					speed = (speed>0 ? Math.ceil(speed): Math.floor(speed));
					if(cur != target){
						mark = false;
						if(attr=="opacity"){
							dom.style.opacity= (cur+speed)/100;
							dom.style.filter = "alpha(opacity="+((cur+speed))+")";
						}else{
							dom.style[attr]= cur+speed+"px";
						}
					}
				}
				//如果执行完毕，
				if(mark){
					//清楚动画
					clearInterval(dom.timer);
					//回调函数，一定要放在下面。要不然你动画没有关闭。
					if(callback)callback.call(dom);
				}
			},30);
		}

		function dom(id){
			return document.getElementById(id);
		};
		//获取css中的样式的值，跟浏览器兼容无关
		function getStyle(dom,attr){
			return window.getComputedStyle ? window.getComputedStyle(dom,false)[attr]:dom.currentStyle[attr];
		};

	</script>
</body>
</html>
