<!doctype html>
<html lang="zh-cn">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
	<title>Document</title>
	<meta name="Keywords" content="" />
	<meta name="Description" content="" />
	<link type="text/css" rel="stylesheet" href="css/common.css" />
	<style>
		.box {
			width:640px;
			height:500px;
			background:green;
			padding:10px;
			margin:100px auto;
			position:relative;
		}
		.box li {
			width:640px;
			height:40px;
			line-height:40px;
			background:#eee;
			margin:10px 0px;
		}
	</style>
</head>
<body>
	<div class="box">
		<ul id="ulDom">
			<li>1&nbsp;&nbsp;&nbsp;<a href="###">上移动</a>&nbsp;&nbsp;&nbsp;<a href="###">下移动</a></li>
			<li>2&nbsp;&nbsp;&nbsp;<a href="###">上移动</a>&nbsp;&nbsp;&nbsp;<a href="###">下移动</a></li>
			<li>3&nbsp;&nbsp;&nbsp;<a href="###">上移动</a>&nbsp;&nbsp;&nbsp;<a href="###">下移动</a></li>
			<li>4&nbsp;&nbsp;&nbsp;<a href="###">上移动</a>&nbsp;&nbsp;&nbsp;<a href="###">下移动</a></li>
			<li>5&nbsp;&nbsp;&nbsp;<a href="###">上移动</a>&nbsp;&nbsp;&nbsp;<a href="###">下移动</a></li>
		</ul>
	</div>
	<script>
		window.onload = function(){
			var ulDom = document.getElementById("ulDom"); // 获取最外层盒子
			var liDoms = ulDom.children; 
			var len = liDoms.length; // 获取元素长度
			var arr = []; // 数组 存放元素坐标位置

			for(var i=0;i<len;i++){
				var top = liDoms[i].offsetTop;
				var left = liDoms[i].offsetLeft;
				arr.push([left,top]);
			};

			for(var i=0;i<len;i++){
				liDoms[i].index = i; // 获取元素索引
				liDoms[i].style.position = "absolute"; // 定位
				liDoms[i].style.left = arr[i][0] + "px";
				liDoms[i].style.top = arr[i][1] + "px";
			}

			for(var i=0;i<len;i++){
				// 向上移动
				liDoms[i].children[0].onclick = function(){ // 点击元素
					var currentDom = this.parentElement; // 获取被点击元素
					var preDom = this.parentElement.previousElementSibling; // 获取被点击元素的上一个元素
					if(preDom){ 
						var cIndex = currentDom.index; // 获取被点击元素的索引
						var pIndex = preDom.index; // 获取上一个元素的索引
						var tempArr = arr[pIndex]; // 存放被点击元素的上一个元素的索引
						ulDom.insertBefore(currentDom,preDom); //交换元素
						move(currentDom,{left:arr[pIndex][0],top:arr[pIndex][1]}); // 运动  被点击元素的坐标位置改变，变为上一个元素的坐标位置
						move(preDom,{left:arr[cIndex][0],top:arr[cIndex][1]});// 运动  被点击元素的上一个元素的坐标位置改变，变为被点击元素的坐标位置
						arr[pIndex] = arr[cIndex]; // 上一个元素的索引变为被点击元素的索引
						arr[cIndex] = tempArr; // 被点击元素的索引变为上一个元素的索引
					}else{
						alert("没有元素了");
					}
				};
				// 向下移动
				liDoms[i].children[1].onclick = function(){
					var currentDom = this.parentElement;
					var nextDom = this.parentElement.nextElementSibling;
					if(nextDom){
						var cIndex = currentDom.index;
						var nIndex = nextDom.index;
						var tempArr = arr[cIndex];
						ulDom.insertBefore(nextDom,currentDom);
						move(currentDom,{left:arr[nIndex][0],top:arr[nIndex][1]});
						move(nextDom,{left:arr[cIndex][0],top:arr[cIndex][1]});
						arr[cIndex] = arr[nIndex];
						arr[nIndex] = tempArr;
					}else{
						alert("没有元素了");
					}
				};
			}
		}


		/*
			时间：2016-01-08
			作者：keke
			动画移动函数
			dom---dom对象
			json===={width:100,height:100}
			callback:回调函数
		*/
		function move(dom,json,callback){
			//让每一次动画都是全新的
			if(dom.timer)clearInterval(dom.timer);
			dom.timer = setInterval(function(){
				//所有元素执行完毕以后的状态
				var mark = true;
				//循环所有动画的属性
				for(var attr in json){
					var cur = null;
					//如果是opacity的透明的动画
					if(attr=="opacity"){
						//获取已经产生的透明度
						cur = getStyle(dom,attr) * 100;
					}else{
						//获取已经执行的距离
						cur = parseInt(getStyle(dom,attr)) || 0;
					}
					//获取目标终止值
					var target = json[attr];
					//速度，*0.2是增加摩擦力
					var speed = (target - cur)/8;
					//如果cur在执行过程中因为已经除去了小数部分。而速度可能会产生小数位 
					//所有说当cur执行的递增，那么可能cur到达不了目标,当速度是大于0的上取整，然后整数+speed==目标
					//199 +1 200 反之向下取整
					speed = (speed>0 ? Math.ceil(speed): Math.floor(speed));
					if(cur != target){
						mark = false;
						if(attr=="opacity"){
							dom.style.opacity= (cur+speed)/100;
							dom.style.filter = "alpha(opacity="+((cur+speed))+")";
						}else{
							dom.style[attr]= cur+speed+"px";
						}
					}
				}
				//如果执行完毕，
				if(mark){
					//清楚动画
					clearInterval(dom.timer);
					//回调函数，一定要放在下面。要不然你动画没有关闭。
					if(callback)callback.call(dom);
				}
			},30);
		}
		function dom(id){
			return document.getElementById(id);
		};

		//获取css中的样式的值，跟浏览器兼容无关
		function getStyle(dom,attr){
			return window.getComputedStyle ? window.getComputedStyle(dom,false)[attr]:dom.currentStyle[attr];
		};
	</script>
</body>
</html>
